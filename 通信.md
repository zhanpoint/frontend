# React前端与Django后端的WebSocket图片处理通知交互流程

## 前端与后端的WebSocket通信流程

### 1. 创建梦境记录并上传图片

**前端发送请求**：
```
POST /api/dreams/
Content-Type: multipart/form-data
Authorization: Bearer <jwt-token>

FormData:
- title: "梦境标题"
- content: "梦境内容..."
- categories: JSON.stringify(["normal", "memorable"])
- tags: JSON.stringify({"theme": [...], "character": [...], "location": [...]})
- imageFile_0: <文件对象>
- imageMetadata_0: JSON.stringify({"position": 50})
- imageFile_1: <文件对象>
- imageMetadata_1: JSON.stringify({"position": 100})
```

**后端响应**：
```json
{
  "id": 123,
  "title": "梦境标题",
  "content": "梦境内容...",
  "categories": ["normal", "memorable"],
  "theme_tags": [...],
  "character_tags": [...],
  "location_tags": [...],
  "images": [],
  "images_status": {
    "status": "processing",
    "websocket_url": "/ws/dream-images/123/",
    "images": []
  },
  "created_at": "2025-04-08T10:00:00"
}
```

### 2. 前端建立WebSocket连接

前端代码:
```javascript
// 从API响应获取WebSocket URL和状态
const { id, images_status } = dreamData;
const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}${images_status.websocket_url}`;

// 创建WebSocket连接
const socket = new WebSocket(wsUrl);

// 设置认证头
socket.onopen = () => {
  const authToken = localStorage.getItem('access_token'); // 获取JWT令牌
  // 发送认证信息
  socket.send(JSON.stringify({
    type: 'authenticate',
    token: authToken
  }));
};

// 处理接收到的消息
socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  
  switch (data.type) {
    case 'connection_established':
      console.log('WebSocket连接已建立');
      break;
      
    case 'image_update':
      handleImageUpdate(data);
      break;
  }
};

// 定期发送心跳
setInterval(() => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: 'ping',
      timestamp: Date.now()
    }));
  }
}, 30000);
```

### 3. 后端Celery任务处理图片并通知前端

**处理开始通知** (后端发送到前端):
```json
{
  "type": "image_update",
  "dream_id": 123,
  "status": "processing",
  "images": [],
  "timestamp": 1649154789.123
}
```

**处理完成通知** (后端发送到前端):
```json
{
  "type": "image_update",
  "dream_id": 123,
  "status": "completed",
  "images": [
    {
      "id": 1,
      "url": "https://example.com/user123/image1.jpg",
      "position": 50
    },
    {
      "id": 2,
      "url": "https://example.com/user123/image2.jpg",
      "position": 100
    }
  ],
  "timestamp": 1649154799.456
}
```

### 4. 前端更新UI显示处理后的图片

```javascript
const handleImageUpdate = (data) => {
  if (data.status === 'processing') {
    // 显示加载状态
    setLoadingImages(true);
  } 
  else if (data.status === 'completed') {
    // 隐藏加载状态
    setLoadingImages(false);
    
    // 保存图片数据
    setImages(data.images);
    
    // 更新梦境内容，在适当位置插入图片
    updateDreamContentWithImages(data.images);
  } 
  else if (data.status === 'failed') {
    setLoadingImages(false);
    // 显示错误消息
    showErrorMessage('图片处理失败，请重试');
  }
};

// 更新梦境内容，插入图片
const updateDreamContentWithImages = (imageList) => {
  // 复制当前梦境数据
  const updatedDream = { ...dream };
  
  // 按位置排序图片
  const sortedImages = [...imageList].sort((a, b) => a.position - b.position);
  
  // 计算并更新内容
  let content = updatedDream.content;
  let offset = 0;
  
  for (const image of sortedImages) {
    const position = image.position + offset;
    const imageMarkdown = `![图片](${image.url})`;
    
    // 在指定位置插入图片
    content = content.substring(0, position) + imageMarkdown + content.substring(position);
    offset += imageMarkdown.length;
  }
  
  // 更新状态
  updatedDream.content = content;
  setDream(updatedDream);
};
```

## 所有交互的数据格式

### 1. 前端发送的WebSocket消息

**认证消息**:
```json
{
  "type": "authenticate",
  "token": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
}
```

**心跳消息**:
```json
{
  "type": "ping",
  "timestamp": 1649154859.123
}
```

### 2. 后端发送的WebSocket消息

**连接成功响应**:
```json
{
  "type": "connection_established",
  "dream_id": "123",
  "message": "连接已建立，等待图片处理状态更新"
}
```

**心跳响应**:
```json
{
  "type": "pong",
  "timestamp": 1649154859.123
}
```

**图片处理状态更新**:
```json
{
  "type": "image_update",
  "dream_id": 123,
  "status": "processing|completed|failed",
  "images": [
    {
      "id": 1,
      "url": "https://example.com/user123/image1.jpg",
      "position": 50
    }
  ],
  "timestamp": 1649154799.456
}
```

### 3. 前端UI状态变化

1. **创建梦境后**: 显示梦境内容，图片位置显示加载中状态
2. **收到处理开始通知**: 保持加载中状态
3. **收到处理完成通知**: 
   - 更新图片URL
   - 隐藏加载中状态
   - 在正确位置显示图片
4. **收到处理失败通知**: 显示错误消息，提示用户重试

通过这种方式，后端可以异步处理图片，而前端能够实时获取处理结果并更新UI，提供更好的用户体验。

## 通信优化重点

### 前端优化措施

1. **连接管理**：
   - 自动重连机制：使用指数退避策略
   - 连接状态跟踪：避免重复连接
   - 连接超时处理：设置10秒超时检测
   - 身份认证状态跟踪：确保操作在认证成功后执行

2. **心跳机制**：
   - 定期发送心跳包保持连接活跃
   - 自动检测心跳失败并重连
   - 优化心跳间隔为25秒，略小于后端超时时间

3. **错误处理**：
   - 增强错误捕获和日志记录
   - 在发送消息和处理响应时添加try-catch
   - 网络异常时平滑重连

4. **UI交互**：
   - 占位图片显示，提前预留位置
   - 图片加载失败时提供友好提示
   - 使用防抖函数处理更新，避免竞态条件
   - 本地存储备份确保刷新后不丢失数据

### 后端优化措施

1. **连接管理**：
   - 认证超时处理：30秒内未认证则关闭连接
   - 连接状态跟踪和日志记录
   - 记录连接持续时间和关闭原因

2. **心跳机制**：
   - 服务器端主动发送心跳包
   - 心跳间隔为30秒，保持长连接稳定

3. **消息发送**：
   - 消息重试机制：失败时自动重试
   - 配置可调的重试次数和延迟
   - 增强错误捕获和记录

4. **安全性**：
   - 严格的认证检查：确保消息只发送给已认证的客户端
   - 关闭未授权连接时返回特定错误码

## 注意事项

1. **前后端心跳协调**：
   - 前端心跳间隔设为25秒，后端为30秒，确保两端都能检测到连接健康状态
   - 确保心跳消息优先处理，防止阻塞

2. **资源清理**：
   - 组件卸载时确保WebSocket连接正确关闭
   - 清理所有定时器和异步任务

3. **图片处理**：
   - 确保图片URL格式验证，防止无效URL导致显示问题
   - 图片插入位置超出内容长度时，优雅地处理为附加到末尾

4. **网络环境适应**：
   - 针对不稳定网络，前端增加了更多重试次数
   - 使用指数退避策略减轻服务器负担

## 错误码定义

| 错误码 | 含义 |
|-------|------|
| 1000 | 正常关闭 |
| 1006 | 异常关闭（连接超时） |
| 4001 | 认证失败 |
| 4003 | 权限验证失败 |
| 4008 | 认证超时 |
